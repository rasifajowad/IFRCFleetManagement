"use server"
import { revalidatePath } from "next/cache"
import { prisma } from "@/lib/db"
import { getCurrentUser } from "@/lib/auth"
import { BookingRepo } from "@/repositories/bookingRepo"
import { RequestRepo } from "@/repositories/requestRepo"
import { VehicleRepo } from "@/repositories/vehicleRepo"
import { UserRepo } from "@/repositories/userRepo"
import {
  CreateRequestSchema,
  ApproveAssignSchema,
  StartTripSchema,
  EndTripSchema,
  AddDriverSchema,
  RemoveDriverSchema,
  AssignVehicleDriverSchema,
  UpdateBookingStatusSchema,
  DeleteBookingSchema,
  UpdateProfileSchema,
  AdminUpdateUserSchema,
  AdminChangeRoleSchema,
  AdminDeleteUserSchema,
} from "@/validation/schemas"

export async function createRequest(formData: FormData) {
  const me = await getCurrentUser()
  if (!me) return
  const raw = Object.fromEntries(formData.entries())
  const parsed = CreateRequestSchema.safeParse(raw)
  if (!parsed.success) return
  const { requesterId, purpose, startLocation, destination, startTime, endTime, notes } = parsed.data as any
  await RequestRepo.create({
    id: `R${Date.now()}`,
    requesterId,
    purpose,
    startLocation,
    destination,
    startTime,
    endTime,
    notes,
    status: 'Pending',
    createdAt: new Date(),
  })
  revalidatePath('/schedule')
  revalidatePath('/my-requests')
  revalidatePath('/requests')
}

export async function approveAndAssign(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = ApproveAssignSchema.safeParse(raw)
  if (!parsed.success) return
  const { reqId, vehicleId, driverId, override } = parsed.data
  const req = await RequestRepo.findById(reqId)
  if (!req) return
  const conflict = await BookingRepo.findConflict(vehicleId, req.startTime, req.endTime)
  if (conflict && !override) return
  await prisma.$transaction([
    prisma.booking.create({
      data: {
        id: `B${Date.now()}`,
        requestId: req.id,
        vehicleId,
        driverId,
        requesterId: req.requesterId,
        purpose: req.purpose,
        startTime: req.startTime,
        endTime: req.endTime,
        status: 'Booked',
        notes: req.notes,
        override,
        createdAt: new Date(),
      },
    }),
    prisma.request.update({ where: { id: req.id }, data: { status: 'Approved' } }),
  ])
  revalidatePath('/schedule')
  revalidatePath('/requests')
}

export async function startTrip(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'driver') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = StartTripSchema.safeParse(raw)
  if (!parsed.success) return
  const { bookingId, startLocation, odometerStart } = parsed.data as any
  await BookingRepo.update(bookingId, { status: 'InUse', actualStart: new Date(), startLocation, odometerStart })
  revalidatePath('/schedule')
  revalidatePath('/my-trips')
}

export async function endTrip(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'driver') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = EndTripSchema.safeParse(raw)
  if (!parsed.success) return
  const { bookingId, endLocation, odometerEnd } = parsed.data as any
  const b = await BookingRepo.findById(bookingId)
  if (!b) return
  if (typeof b.odometerStart === 'number' && odometerEnd < b.odometerStart) return
  await BookingRepo.update(bookingId, { status: 'Completed', actualEnd: new Date(), endLocation, odometerEnd })
  revalidatePath('/schedule')
  revalidatePath('/my-trips')
}

// Admin actions
export async function addDriver(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = AddDriverSchema.safeParse(raw)
  if (!parsed.success) return
  await UserRepo.createDriver(parsed.data.name)
  revalidatePath('/admin')
}

export async function removeDriver(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = RemoveDriverSchema.safeParse(raw)
  if (!parsed.success) return
  const id = parsed.data.driverId
  await prisma.$transaction([
    prisma.vehicle.updateMany({ where: { assignedDriverId: id }, data: { assignedDriverId: null } }),
    prisma.booking.updateMany({ where: { driverId: id, status: { not: 'Completed' } }, data: { status: 'Completed' } }),
    prisma.user.delete({ where: { id } })
  ])
  revalidatePath('/admin')
  revalidatePath('/schedule')
}

export async function assignVehicleDriver(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = AssignVehicleDriverSchema.safeParse(raw)
  if (!parsed.success) return
  await VehicleRepo.updateAssignedDriver(parsed.data.vehicleId, parsed.data.driverId ?? null)
  revalidatePath('/admin')
}

export async function updateBookingStatus(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = UpdateBookingStatusSchema.safeParse(raw)
  if (!parsed.success) return
  await BookingRepo.update(parsed.data.bookingId, { status: parsed.data.status })
  revalidatePath('/admin')
  revalidatePath('/schedule')
}

export async function deleteBooking(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = DeleteBookingSchema.safeParse(raw)
  if (!parsed.success) return
  await BookingRepo.deleteById(parsed.data.bookingId)
  revalidatePath('/admin')
  revalidatePath('/schedule')
}

export async function updateProfile(formData: FormData) {
  const me = await getCurrentUser()
  if (!me) return
  const raw = Object.fromEntries(formData.entries())
  const parsed = UpdateProfileSchema.safeParse(raw)
  if (!parsed.success) return
  const { name, phone, department, title, location, driverLicenseNo, driverLicenseExpiry } = parsed.data
  if (me.role === 'driver') {
    // Enforce driver license validation for drivers
    const ln = (driverLicenseNo || '').trim()
    if (!ln || ln.length !== 16 || !/^[A-Za-z0-9]{16}$/.test(ln)) return
    if (!driverLicenseExpiry) return
    const today = new Date(); today.setHours(0,0,0,0)
    const exp = new Date(driverLicenseExpiry); exp.setHours(0,0,0,0)
    if (exp < today) return
  }
  await prisma.user.update({ where: { id: me.id }, data: { name, phone, department, title, location, driverLicenseNo, driverLicenseExpiry } })
  // Revalidate pages that show identity
  revalidatePath('/profile')
  revalidatePath('/my-requests')
  revalidatePath('/my-trips')
  revalidatePath('/admin')
}

// Admin: members management
export async function adminUpdateUser(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = AdminUpdateUserSchema.safeParse(raw)
  if (!parsed.success) return
  const { id, ...data } = parsed.data
  await prisma.user.update({ where: { id }, data })
  revalidatePath('/admin/members')
}

export async function adminChangeRole(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = AdminChangeRoleSchema.safeParse(raw)
  if (!parsed.success) return
  const { id, role, reassignToDriverId } = parsed.data
  const user = await prisma.user.findUnique({ where: { id } })
  if (!user) return
  if (user.role === 'officer' && role !== 'officer') {
    const count = await prisma.user.count({ where: { role: 'officer' as any, active: true } })
    if (count <= 1) return // prevent removing last officer
  }
  if (user.role === 'driver' && role !== 'driver') {
    // force reassignment: need replacement driver
    if (!reassignToDriverId) return
    await prisma.$transaction([
      prisma.vehicle.updateMany({ where: { assignedDriverId: id }, data: { assignedDriverId: reassignToDriverId } }),
      prisma.booking.updateMany({ where: { driverId: id, status: { not: 'Completed' } }, data: { driverId: reassignToDriverId } }),
      prisma.user.update({ where: { id }, data: { role } })
    ])
  } else {
    await prisma.user.update({ where: { id }, data: { role } })
  }
  revalidatePath('/admin/members')
  revalidatePath('/admin')
}

export async function adminDeleteUser(formData: FormData) {
  const me = await getCurrentUser()
  if (!me || me.role !== 'officer') return
  const raw = Object.fromEntries(formData.entries())
  const parsed = AdminDeleteUserSchema.safeParse(raw)
  if (!parsed.success) return
  const { id } = parsed.data
  const user = await prisma.user.findUnique({ where: { id } })
  if (!user) return
  if (user.role === 'officer') {
    const count = await prisma.user.count({ where: { role: 'officer' as any, active: true } })
    if (count <= 1) return // prevent deleting last officer
  }
  // Prevent delete if referenced by bookings (driver/requester)
  const blocks = await prisma.booking.count({ where: { OR: [{ driverId: id }, { requesterId: id }] } })
  if (blocks > 0) return
  await prisma.user.delete({ where: { id } })
  revalidatePath('/admin/members')
}
